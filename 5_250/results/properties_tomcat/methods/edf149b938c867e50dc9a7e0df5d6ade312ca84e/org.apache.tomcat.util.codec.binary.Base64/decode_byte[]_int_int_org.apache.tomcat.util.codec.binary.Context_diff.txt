                                                                                                     | // Implementation of the Encoder Interface                                                          
/**                                                                                                    /**                                                                                                 
* &lt;p&gt;                                                                                            * &lt;p&gt;                                                                                         
* Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least    * Decodes all of the provided data, starting at inPos, for inAvail bytes. Should be called at least 
* with the data to decode, and once with inAvail set to "-1" to alert decoder that EOF has been reac   * with the data to decode, and once with inAvail set to "-1" to alert decoder that EOF has been reac
* call is not necessary when decoding, but it doesn't hurt, either.                                    * call is not necessary when decoding, but it doesn't hurt, either.                                 
* &lt;/p&gt;                                                                                           * &lt;/p&gt;                                                                                        
* &lt;p&gt;                                                                                            * &lt;p&gt;                                                                                         
* Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since    * Ignores all non-base64 characters. This is how chunked (e.g. 76 character) data is handled, since 
* silently ignored, but has implications for other bytes, too. This method subscribes to the garbage   * silently ignored, but has implications for other bytes, too. This method subscribes to the garbage
* garbage-out philosophy: it will not check the provided data for validity.                            * garbage-out philosophy: it will not check the provided data for validity.                         
* &lt;/p&gt;                                                                                           * &lt;/p&gt;                                                                                        
* &lt;p&gt;                                                                                            * &lt;p&gt;                                                                                         
* Thanks to "commons" project in ws.apache.org for the bitwise operations, and general approach.       * Thanks to "commons" project in ws.apache.org for the bitwise operations, and general approach.    
* https://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/                             * https://svn.apache.org/repos/asf/webservices/commons/trunk/modules/util/                          
* &lt;/p&gt;                                                                                           * &lt;/p&gt;                                                                                        
*                                                                                                      *                                                                                                   
* @param in                                                                                            * @param in                                                                                         
*            byte[] array of ascii data to base64 decode.                                              *            byte[] array of ascii data to base64 decode.                                           
* @param inPos                                                                                         * @param inPos                                                                                      
*            Position to start reading data from.                                                      *            Position to start reading data from.                                                   
* @param inAvail                                                                                       * @param inAvail                                                                                    
*            Amount of bytes available from input for decoding.                                        *            Amount of bytes available from input for decoding.                                     
* @param context                                                                                       * @param context                                                                                    
*            the context to be used                                                                    *            the context to be used                                                                 
*/                                                                                                     */                                                                                                  
@Override                                                                                              @Override                                                                                           
void decode(final byte[] in, int inPos, final int inAvail, final Context context) {                    void decode(final byte[] in, int inPos, final int inAvail, final Context context) {                 
if (context.eof) {                                                                                     if (context.eof) {                                                                                  
return;                                                                                                return;                                                                                             
}                                                                                                      }                                                                                                   
if (inAvail &lt; 0) {                                                                                  if (inAvail &lt; 0) {                                                                               
context.eof = true;                                                                                    context.eof = true;                                                                                 
}                                                                                                      }                                                                                                   
for (int i = 0; i &lt; inAvail; i++) {                                                                 for (int i = 0; i &lt; inAvail; i++) {                                                              
final byte[] buffer = ensureBufferSize(decodeSize, context);                                           final byte[] buffer = ensureBufferSize(decodeSize, context);                                        
final byte b = in[inPos++];                                                                            final byte b = in[inPos++];                                                                         
if (b == pad) {                                                                                        if (b == pad) {                                                                                     
// We're done.                                                                                         // We're done.                                                                                      
context.eof = true;                                                                                    context.eof = true;                                                                                 
break;                                                                                                 break;                                                                                              
}                                                                                                      }                                                                                                   
if (b &gt;= 0 && b &lt; decodeTable.length) {                                                          if (b &gt;= 0 && b &lt; decodeTable.length) {                                                       
final int result = decodeTable[b];                                                                     final int result = decodeTable[b];                                                                  
if (result &gt;= 0) {                                                                                  if (result &gt;= 0) {                                                                               
context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;                                     context.modulus = (context.modulus + 1) % BYTES_PER_ENCODED_BLOCK;                                  
context.ibitWorkArea = (context.ibitWorkArea &lt;&lt; BITS_PER_ENCODED_BYTE) + result;                 context.ibitWorkArea = (context.ibitWorkArea &lt;&lt; BITS_PER_ENCODED_BYTE) + result;              
if (context.modulus == 0) {                                                                            if (context.modulus == 0) {                                                                         
buffer[context.pos++] = (byte) ((context.ibitWorkArea &gt;&gt; 16) & MASK_8BITS);                      buffer[context.pos++] = (byte) ((context.ibitWorkArea &gt;&gt; 16) & MASK_8BITS);                   
buffer[context.pos++] = (byte) ((context.ibitWorkArea &gt;&gt; 8) & MASK_8BITS);                       buffer[context.pos++] = (byte) ((context.ibitWorkArea &gt;&gt; 8) & MASK_8BITS);                    
buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);                                    buffer[context.pos++] = (byte) (context.ibitWorkArea & MASK_8BITS);                                 
}                                                                                                      }                                                                                                   
}                                                                                                      }                                                                                                   
}                                                                                                      }                                                                                                   
}                                                                                                      }                                                                                                   
// Two forms of EOF as far as base64 decoder is concerned: actual                                      // Two forms of EOF as far as base64 decoder is concerned: actual                                   
// EOF (-1) and first time '=' character is encountered in stream.                                     // EOF (-1) and first time '=' character is encountered in stream.                                  
// This approach makes the '=' padding characters completely optional.                                 // This approach makes the '=' padding characters completely optional.                              
if (context.eof && context.modulus != 0) {                                                             if (context.eof && context.modulus != 0) {                                                          
final byte[] buffer = ensureBufferSize(decodeSize, context);                                           final byte[] buffer = ensureBufferSize(decodeSize, context);                                        
// We have some spare bits remaining                                                                   // We have some spare bits remaining                                                                
// Output all whole multiples of 8 bits and ignore the rest                                            // Output all whole multiples of 8 bits and ignore the rest                                         
switch(context.modulus) {                                                                              switch(context.modulus) {                                                                           
// case 0 : // impossible, as excluded above                                                           // case 0 : // impossible, as excluded above                                                        
case // 6 bits - ignore entirely                                                                     | // case 1 : // 6 bits - invalid - use default below                                                 
1:                                                                                                   |                                                                                                     
// TODO not currently tested; perhaps it is impossible?                                              |                                                                                                     
break;                                                                                               |                                                                                                     
case // 12 bits = 8 + 4                                                                                case // 12 bits = 8 + 4                                                                             
2:                                                                                                     2:                                                                                                  
validateCharacter(MASK_4BITS, context);                                                                validateCharacter(MASK_4BITS, context);                                                             
// dump the extra 4 bits                                                                               // dump the extra 4 bits                                                                            
context.ibitWorkArea = context.ibitWorkArea &gt;&gt; 4;                                                context.ibitWorkArea = context.ibitWorkArea &gt;&gt; 4;                                             
buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);                                  buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);                               
break;                                                                                                 break;                                                                                              
case // 18 bits = 8 + 8 + 2                                                                            case // 18 bits = 8 + 8 + 2                                                                         
3:                                                                                                     3:                                                                                                  
validateCharacter(MASK_2BITS, context);                                                                validateCharacter(MASK_2BITS, context);                                                             
// dump 2 bits                                                                                         // dump 2 bits                                                                                      
context.ibitWorkArea = context.ibitWorkArea &gt;&gt; 2;                                                context.ibitWorkArea = context.ibitWorkArea &gt;&gt; 2;                                             
buffer[context.pos++] = (byte) ((context.ibitWorkArea &gt;&gt; 8) & MASK_8BITS);                       buffer[context.pos++] = (byte) ((context.ibitWorkArea &gt;&gt; 8) & MASK_8BITS);                    
buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);                                  buffer[context.pos++] = (byte) ((context.ibitWorkArea) & MASK_8BITS);                               
break;                                                                                                 break;                                                                                              
default:                                                                                               default:                                                                                            
throw new IllegalStateException(sm.getString("base64.impossibleModulus", Integer.valueOf(context.mod   throw new IllegalStateException(sm.getString("base64.impossibleModulus", Integer.valueOf(context.mod
}                                                                                                      }                                                                                                   
}                                                                                                      }                                                                                                   
}                                                                                                      }                                                                                                   
