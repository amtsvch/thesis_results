/**                                                                                                    /**                                                                                                 
* The actual code which drains the channel associated with                                             * The actual code which drains the channel associated with                                          
* the given key.  This method assumes the key has been                                                 * the given key.  This method assumes the key has been                                              
* modified prior to invocation to turn off selection                                                   * modified prior to invocation to turn off selection                                                
* interest in OP_READ.  When this method completes it                                                  * interest in OP_READ.  When this method completes it                                               
* re-enables OP_READ and calls wakeup() on the selector                                                * re-enables OP_READ and calls wakeup() on the selector                                             
* so the selector will resume watching this channel.                                                   * so the selector will resume watching this channel.                                                
* @param key The key to process                                                                        * @param key The key to process                                                                     
* @param reader The reader                                                                             * @param reader The reader                                                                          
* @throws Exception IO error                                                                           * @throws Exception IO error                                                                        
*/                                                                                                     */                                                                                                  
protected void drainChannel(final SelectionKey key, ObjectReader reader) throws Exception {            protected void drainChannel(final SelectionKey key, ObjectReader reader) throws Exception {         
reader.access();                                                                                       reader.access();                                                                                    
ReadableByteChannel channel = (ReadableByteChannel) key.channel();                                     ReadableByteChannel channel = (ReadableByteChannel) key.channel();                                  
int count = -1;                                                                                        int count = -1;                                                                                     
// make buffer empty                                                                                   // make buffer empty                                                                                
buffer.clear();                                                                                        buffer.clear();                                                                                     
SocketAddress saddr = null;                                                                            SocketAddress saddr = null;                                                                         
if (channel instanceof SocketChannel) {                                                                if (channel instanceof SocketChannel) {                                                             
// loop while data available, channel is non-blocking                                                  // loop while data available, channel is non-blocking                                               
while ((count = channel.read(buffer)) &gt; 0) {                                                        while ((count = channel.read(buffer)) &gt; 0) {                                                     
// make buffer readable                                                                                // make buffer readable                                                                             
buffer.flip();                                                                                         buffer.flip();                                                                                      
if (buffer.hasArray())                                                                               | if (buffer.hasArray()) {                                                                            
reader.append(buffer.array(), 0, count, false);                                                        reader.append(buffer.array(), 0, count, false);                                                     
else                                                                                                 | } else {                                                                                            
reader.append(buffer, count, false);                                                                   reader.append(buffer, count, false);                                                                
                                                                                                     | }                                                                                                   
// make buffer empty                                                                                   // make buffer empty                                                                                
buffer.clear();                                                                                        buffer.clear();                                                                                     
// do we have at least one package?                                                                    // do we have at least one package?                                                                 
if (reader.hasPackage())                                                                             | if (reader.hasPackage()) {                                                                          
break;                                                                                                 break;                                                                                              
}                                                                                                      }                                                                                                   
                                                                                                     | }                                                                                                   
} else if (channel instanceof DatagramChannel) {                                                       } else if (channel instanceof DatagramChannel) {                                                    
DatagramChannel dchannel = (DatagramChannel) channel;                                                  DatagramChannel dchannel = (DatagramChannel) channel;                                               
saddr = dchannel.receive(buffer);                                                                      saddr = dchannel.receive(buffer);                                                                   
// make buffer readable                                                                                // make buffer readable                                                                             
buffer.flip();                                                                                         buffer.flip();                                                                                      
if (buffer.hasArray())                                                                               | if (buffer.hasArray()) {                                                                            
reader.append(buffer.array(), 0, buffer.limit() - buffer.position(), false);                           reader.append(buffer.array(), 0, buffer.limit() - buffer.position(), false);                        
else                                                                                                 | } else {                                                                                            
reader.append(buffer, buffer.limit() - buffer.position(), false);                                      reader.append(buffer, buffer.limit() - buffer.position(), false);                                   
                                                                                                     | }                                                                                                   
// make buffer empty                                                                                   // make buffer empty                                                                                
buffer.clear();                                                                                        buffer.clear();                                                                                     
// did we get a package                                                                                // did we get a package                                                                             
count = reader.hasPackage() ? 1 : -1;                                                                  count = reader.hasPackage() ? 1 : -1;                                                               
}                                                                                                      }                                                                                                   
int pkgcnt = reader.count();                                                                           int pkgcnt = reader.count();                                                                        
if (count &lt; 0 && pkgcnt == 0) {                                                                     if (count &lt; 0 && pkgcnt == 0) {                                                                  
// end of stream, and no more packages to process                                                      // end of stream, and no more packages to process                                                   
remoteEof(key);                                                                                        remoteEof(key);                                                                                     
return;                                                                                                return;                                                                                             
}                                                                                                      }                                                                                                   
ChannelMessage[] msgs = pkgcnt == 0 ? ChannelData.EMPTY_DATA_ARRAY : reader.execute();                 ChannelMessage[] msgs = pkgcnt == 0 ? ChannelData.EMPTY_DATA_ARRAY : reader.execute();              
// register to read new data, before we send it off to avoid dead locks                                // register to read new data, before we send it off to avoid dead locks                             
registerForRead(key, reader);                                                                          registerForRead(key, reader);                                                                       
for (ChannelMessage msg : msgs) {                                                                      for (ChannelMessage msg : msgs) {                                                                   
/**                                                                                                    /**                                                                                                 
* Use send ack here if you want to ack the request to the remote                                       * Use send ack here if you want to ack the request to the remote                                    
* server before completing the request                                                                 * server before completing the request                                                              
* This is considered an asynchronous request                                                           * This is considered an asynchronous request                                                        
*/                                                                                                     */                                                                                                  
if (ChannelData.sendAckAsync(msg.getOptions())) {                                                      if (ChannelData.sendAckAsync(msg.getOptions())) {                                                   
sendAck(key, (WritableByteChannel) channel, Constants.ACK_COMMAND, saddr);                             sendAck(key, (WritableByteChannel) channel, Constants.ACK_COMMAND, saddr);                          
}                                                                                                      }                                                                                                   
try {                                                                                                  try {                                                                                               
if (Logs.MESSAGES.isTraceEnabled()) {                                                                  if (Logs.MESSAGES.isTraceEnabled()) {                                                               
try {                                                                                                  try {                                                                                               
Logs.MESSAGES.trace("NioReplicationThread - Received msg:" + new UniqueId(msg.getUniqueId()) + " at    Logs.MESSAGES.trace("NioReplicationThread - Received msg:" + new UniqueId(msg.getUniqueId()) + " at 
} catch (Throwable t) {                                                                                } catch (Throwable t) {                                                                             
}                                                                                                      }                                                                                                   
}                                                                                                      }                                                                                                   
// process the message                                                                                 // process the message                                                                              
getCallback().messageDataReceived(msg);                                                                getCallback().messageDataReceived(msg);                                                             
/**                                                                                                    /**                                                                                                 
* Use send ack here if you want the request to complete on this                                        * Use send ack here if you want the request to complete on this                                     
* server before sending the ack to the remote server                                                   * server before sending the ack to the remote server                                                
* This is considered a synchronized request                                                            * This is considered a synchronized request                                                         
*/                                                                                                     */                                                                                                  
if (ChannelData.sendAckSync(msg.getOptions()))                                                       | if (ChannelData.sendAckSync(msg.getOptions())) {                                                    
sendAck(key, (WritableByteChannel) channel, Constants.ACK_COMMAND, saddr);                             sendAck(key, (WritableByteChannel) channel, Constants.ACK_COMMAND, saddr);                          
                                                                                                     | }                                                                                                   
} catch (RemoteProcessException e) {                                                                   } catch (RemoteProcessException e) {                                                                
if (log.isDebugEnabled())                                                                            | if (log.isDebugEnabled()) {                                                                         
log.error(sm.getString("nioReplicationTask.process.clusterMsg.failed"), e);                            log.error(sm.getString("nioReplicationTask.process.clusterMsg.failed"), e);                         
if (ChannelData.sendAckSync(msg.getOptions()))                                                       | }                                                                                                   
                                                                                                     | if (ChannelData.sendAckSync(msg.getOptions())) {                                                    
sendAck(key, (WritableByteChannel) channel, Constants.FAIL_ACK_COMMAND, saddr);                        sendAck(key, (WritableByteChannel) channel, Constants.FAIL_ACK_COMMAND, saddr);                     
                                                                                                     | }                                                                                                   
} catch (Exception e) {                                                                                } catch (Exception e) {                                                                             
log.error(sm.getString("nioReplicationTask.process.clusterMsg.failed"), e);                            log.error(sm.getString("nioReplicationTask.process.clusterMsg.failed"), e);                         
if (ChannelData.sendAckSync(msg.getOptions()))                                                       | if (ChannelData.sendAckSync(msg.getOptions())) {                                                    
sendAck(key, (WritableByteChannel) channel, Constants.FAIL_ACK_COMMAND, saddr);                        sendAck(key, (WritableByteChannel) channel, Constants.FAIL_ACK_COMMAND, saddr);                     
}                                                                                                      }                                                                                                   
                                                                                                     | }                                                                                                   
if (getUseBufferPool()) {                                                                              if (getUseBufferPool()) {                                                                           
BufferPool.getBufferPool().returnBuffer(msg.getMessage());                                             BufferPool.getBufferPool().returnBuffer(msg.getMessage());                                          
msg.setMessage(null);                                                                                  msg.setMessage(null);                                                                               
}                                                                                                      }                                                                                                   
}                                                                                                      }                                                                                                   
if (count &lt; 0) {                                                                                    if (count &lt; 0) {                                                                                 
remoteEof(key);                                                                                        remoteEof(key);                                                                                     
}                                                                                                      }                                                                                                   
}                                                                                                      }                                                                                                   
